2020년 11월 5일


상속

1. 기본 상속
[접근제한자][예약어] class 자식클래스명 extends 부모클래스명{
}
- 자식클래스를 이용해서 객체를 생성하면 -> 부모클래스 멤버 사용이 가능하다.

---------------------------------------------------------------------------------------

2. 부모클래스 멤버접근권한
- public : 자식/외부 모든 클래스에서 사용 가능
- protected : 자식/ 같은 패키지 클래서에서 사용 가능
	같은 패키지 안의 다른 클래스 안에서 사용 가능 (Run)도 사용 가능 (일단 같은 패키지면 사용 가능)
	패키지가 다르면 다른 패키지의 자식 클래스에서만 사용 가능하다
	꼭 필요한 경우가 아니라면 private 쓰는 게 좋다 (정보 은닉을 위해서)  
- private : 부모클래스 내부에서만 사용 가능


---------------------------------------------------------------------------------------


3. 생성자
자식 클래스를 이용해서 객체를 생성을 하게 되면 
자식클래스 생성자 실행(가장 첫줄에서 부모클래스 생성자를 호출함)
 -> 부모클래스의 생성자 실행-> 자식 생성자 실행

- super()와 super.

* 자식클래스 생성자의 첫줄에는 부모클래스 생성자 호출부가 자동으로 포함되어 있음
	super();
* 부모클래스의 매개변수 있는 생성자를 사용하고 싶으면 명시적으로 작성해야 한다.
	super(매개변수);
	항상 가장 첫줄에 적어줘야 함
 
* super. -> 부모 안에 있는 메서드, 필드를 사용하고 싶으면 사용
상속을 통한 자식 클래스 정의 시 해당 자식클래스의 부모 객체를 가리키는 참조변수

예)
부모클래스에도 setName 메서드가 있고
	public void setName(String name) {
		System.out.println("부모 setName");
		this.name = name;
	}
자식클래스에도 setName 메서드가 있을 때
	public void setName(String name) {
		System.out.println("자식 setName");
	}
자식클래스에서 부모클래스에 있는 setName 메서드가 쓰고 싶다면?
super.setName(); 이라고 해줘야 한다.


---------------------------------------------------------------------------------------

4. 오버라이딩(Overriding) (오버로딩과 조금 다름)
자식 클래스가 상속 받은 부모 메서드를 재작성 하는 것
부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다
고쳐지면 부모 것이 아닌 자식 것이 사용된다.

상속관계에서 부모와 자식간의 메서드를 결정할 때 사용한다
메서드 이름과 매개변수가 똑같아야 한다

외부에서 (자식이 오버라이딩 하기 전의 메서드를) 자식을 통해 부모것 쓰고 싶어 
-> 자식이 다시 정의해야 한다.

- 특징
접근 제어자를 부모 것 보다 같거나 넓은 범위로 변경 가능
private로 되어있던 것을 protected나 public으로 변경 가능하지만
protected로 되어 있는 것을 private으로 변경하는 것은 안된다.

- 성립 조건
부모 클래스의 메소드와 자식 클래스의 메소드 비교
- 메소드 이름 동일
- 매개변수의 개수, 타입 동일
- 리턴 타입 동일
- 접근제한자는 부모클래스의 메소드와 같거나 더 넓은 범위
- 예외 발생시 같은 예외 형식이거나, 더 구체적인 예외 형식
- private 메소드 오버라이딩 불가
- final 메소드 오버라이딩 불가



---------------------------------------------------------------------------------------

5. 오버로딩(Overroading)
한 클래스 내에서 같은 이름의 메소드를 여러 개 정의하는 것
(매개변수 없는 것, 매개변수 하나 있는것, 매개변수 두개 있는 것 등등)

- 성립 조건
같은 메소드 이름
다른 매개변수 변수 선언부(매개변수 타입,개수,순서)

- 주의 사항
메소드의 리턴타입은 오버로딩 조건과 관계 없음


---------------------------------------------------------------------------------------

6. final 예약어
'고정' , '최종적인'

- final 클래스
상속이 불가능한 클래스
public final class FinalClass {}
자식클래스를 만들고 싶지 않을 때 붙임

- final 메소드
상속 시 오버라이딩이 불가능한 메소드
public final void method() {}
자식이 이걸 가져다가 바꿔서 쓰지 못하도록

대상 - 사용가능한 제어자/예약어
클래서 - public, (default), final, abstract
메소드 - 모든 접근 제어자, final, abstract, static
필드(변수) - 모든 접근 제어자, final, static 
지역변수 - final

- 유의 사항
클래스에 abstract(추상 클래스- 자기 자신만으로는 객체를 생성할 수 없는, 상속만을 위해 만들어진 클래스)와 final 동시에 사용 불가능

메소드에 static (객체 만들기도 전에 모든 애들이 사용할 수 있는 것) 과 abstract(오버라이딩을 쓰기 위해 만든 메서드) 동시에 사용 불가능

abstract 메소드의 접근제어자로 private 불가능


---------------------------------------------------------------------------------------
* 헷갈리는 것
- static 필드
클래스를 이용해서 만든 객체들이 공통으로 쓸 수 있는 공간


- static 메서드
따로 객체를 생성하지 않더라도 쓸 수 있는 메서드
예 ) 메인메서드, 프린트메서드
입력은 스캐너 객체 생성했어야 함

InheritExam01 이라는 라이브러리 클래스에

public static void speak() {
	System.out.println("말하다");
	}
speak라는 static 메서드를 만들었다.

실행 클래스에서 InheritExam01 객체를 만들지 않아도
InheritExam01.speak(); 해서 사용할 수 있다.


---------------------------------------------------------------------------------------



다형성 (Polymorphism)

객체지향 프로그래밍의 3대 특징 중 하나
'여러 개의 형태를 갖는다'
상속을 이용해 부모 타입으로부터 파생된 여러 가지 타입의 자식 객체를 부모 클래스 타입 하나로 다룰 수 있는 기술


- 클래스 형변환
클래스는 상속 관계에서만 형변환을 할 수 있다.

- 업 캐스팅(Up Casting)
상속 관계에 있는 부모, 자식 클래스 간에 부모타입의 참조형 변수가 모든 자식 타입의 객체 주소를 받을 수 있음
자식을 부모형태로 쓰는 것

//sonata 클래스는 car 클래스의 후손
Car c = new Sonata();
부모 클래스의 참조변수를 만들어서 담아서 쓸 수 있다.
// Sonata 클래스형에서 Car 클래스형으로 바뀜

* 자식 객체의 주소를 전달받은 부모타입의 참조변수를 통해서 사용할 수 있는 
후손의 정보는 원래 부모타입이었던 멤버만 참조 가능

예시)
polymorphism - Animal 


- 다운 캐스팅(Down Casting)
부모를 자식형태로 쓰는 것
자식 객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야 할 경우.
부모 클래스 타입의 참조형 변수를 자식 클래스 타입으로 (일시적으로)형 변환하는 것
자동으로 처리되지 않기 때문에 반드시 후손 타입 명시해서 형 변환

//Sonata 클래스는 Car 클래스의 후손
Car c = new Sonata();
((Sonata)c).moveSonata();

* 클래스 간의 형 변환은 반드시 상속 관계에 있는 클래스끼리만 가능

예시)
	case 1:
		a = new Cat();
		((Cat)a).grumming();
		break;
	case 2:
		a = new Dog();
		((Dog)a).protect();
		break;
	case 3:
		a = new Rabbit();
		((Rabbit)a).jump();
