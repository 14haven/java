2020년 11월 6일


- 업캐스팅
어차피 똑같은 부모님을 가지고 있기때문에
부모님 클래스 타입의 참조변수 하나 만들어놓고 여러 자식을 담을 수 있다.
어떤 자식을 담느냐에 따라 코드는 같지만 실제 내용은 달라질 수 있다.

----------------------------------------------------------------------------------

- 객체배열과 다형성

다형성을 이용하여 상속 관계에 있는 하나의 부모 클래스 타입의
배열 공간에 여러 종류의 자식 클래스 객체 저장 가능

Car[] carArr = new Car[5];

carrArr[0] = new 	

----------------------------------------------------------------------------------

- 매개변수와 다형성

동작하는 형태를 메서드로 만들고 싶다.
원래같으면

Animal을 상속받은 Cat, Dog, Rabbit 클래스
private Cat c;
private Dog d;
private Rabbit r;
public void catBehaivor(){ //고양이가 하는 행동에 대해서는 따로 만들어 놓고
	c = new Cat();
	c.walk();
	c.eat();
	c.speak();
}
public void dogBehavior(){ //강아지가 하는 행동에 대해서는 따로 또 만들어 놓고
	d = new Dog();
	d.walk();
	d.eat();
	d.speak();
}
pulic void rabbitBehavior(){ // 토끼가 하는 행도에 대해서 또 따로 만들어 놓는다.
	r = new Rabbit();
	r.walk();
	r.eat();
	r.speak();
}
이렇게 따로따로 메서드를 만들어 줘야 했는데 일일이 만들기 귀찮으니까 메서드 만들어서 통일하자.

어떤 객체 주소를 넘겨 받는가에 따라 결과가 달라지게 하기 위해
Animal 부모클래스 타입으로 통일시켜서 자식 객체주소들을 담을 수 있게 해준다.


private Animal ani; 

public void behavior(Animal ani){ 
	this.ani = ani;
	ani.walk();
	ani.eat();
	ani.speak();
}

// 실행파일 
ZooController zoo = new ZooController();

zoo.behavior(new Cat()); // 객체를 생성해서 인자값으로 넘겨줌
zoo.behavior(new Dog());
zoo.behavior(new Rabbit());



// 메소드의 매개변수 부분에서 객체의 주소를 받아서 사용하는 경우
   여러 자식 객체의 주소를 받아야 할 경우, 부모 클래스의 참조변수를 만들어서 받아줄 수 있음



----------------------------------------------------------------------------------


- 다운 캐스팅

부모가 임시로 한번만 자식인 척

for(int i=0; i<aniArr2.length ; i++) {

	aniArr2[i].walk();
	aniArr2[i].eat();
	aniArr2[i].speak();

	// 다운캐스팅 적용
//	if(i==0) {
//	((Cat)aniArr2[i]).grumming();
//	} else if(i==1) {
//	((Dog)aniArr2[i]).protect();
//	} else if (i==2) {
//	((Rabbit)aniArr2[i]).jump();
//	}

	//instacneof 연산자 
	// 사용법 : 참조변수 instanceof 클래스
	// 결과 : 해당 참조변수가 가리키는 객체가 비교하고자 하는 클래스와 일치하면 true
	// 	아니면 false
	// 참조변수를 이용해서 참조변수가 가리키는 객체가 무엇인지 알아내는 연산자
	// 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
	// 주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.
	if(aniArr2[i] instanceof Cat) { //i 번째가 가리키는게 Cat이니? 맞으면 true 반환, 아니면 false 반환
		((Cat)aniArr2[i]).grumming();
	} else if(aniArr2[i] instanceof Dog) {
		((Dog)aniArr2[i]).protect();
	} else if (aniArr2[i] instanceof Rabbit) {
		((Rabbit)aniArr2[i]).jump();
	}
}
	




----------------------------------------------------------------------------------

- 바인딩

실제 실행할 메소드 코드와 호출하는 코드를 연결 시키는 것
프로그램이 실행되기 전에 컴파일링 되면서 모든 메소드는 정적 바인딩이 됨

동적 바인딩
컴파일 시 정적 바인딩된 메소드를 실행할 당시의 객체 타입을 기준으로 바인딩 되는 것


Animal a = new Animal();
a.speak(); 하면 Animal 클래스에 있는 speak를 실행하는건데
만약 Animal a = new Cat();
      Animal a = new Dog();
이렇게 a에 다른 객체도 담고 a.speak(); 를 하면?
Cat에 있는 speak를 실행해야 할까 Dog에 있는 speak를 실행해야 할까?
실행하는 당시의 객체타입을 기준으로 바인딩 한다
 

동적 바인딩 성립 요건
상속 관계로 이루어져 다형성이 적용된 경우,
메소드 오버라이딩이 되어 있으면 정적으로 바인딩 된 메소드 코드보다 오버라이딩 된 메소드 코드를 우선적으로 수행



----------------------------------------------------------------------------------

- 추상 클래스 (abstract class)

추상 클래스란 하나 이상의 추상메소드를 포함하는 클래스이다.
추상 메소드는 선언만 있고 본체만 없는 함수이며 선언부에 'abstract'라는 키워드를 붙인다.
추상 메소드가 포함되었따면 클래스도 추상 클래스이므로 클래스명 앞에도 'abstract' 키워드를 붙여야 한다.


1. 무조건 미완성 메소드가 있어야 하는 건 아니다.
일반 클래스인데 가만보니 자기 혼자로는 사용할일(객체 만들 일)이 없을 것 같아,
자식 클래스에서 상속을 받아서 사용 할 일만 있는 것 같아 -> 그냥 추상 클래스로 만든다.

2. 미완성 클래스는 객체를 생성할 수 없는 클래스가 된다. (객체화 불가능)
이 클래스를 이용해서 참조변수까지는 만들 수 있는데 new 클래스(); 해서 객체를 만들 수 없다.
-> 반드시 상속하여 객체 생성 = 추상클래스와 실체클래스는 상속관계이다.
abstract 메소드가 포함된 클래스는 반드시 abstract 클래스


본체가 없다? -> 반환자료형, 메소드명 (매개변수){ 실제 기능 } 
중괄호로 묶어서 실제 기능을 구현한 부분을 본체라고 한다.
이 본체가 없는 메소드를 추상 메소드라고 한다
이 메소드 있을거야 라고 하는데 기능은 없다 -> 실행 할 수 없다
-> 미완성 메소드


예) Animal 클래스의 speak 메소드 
어차피 자식들이 다 다시 정의 할거니까 굳이 Animal에서 기능을 정의 할 필요가 없음
추상 메서드가 된다.


* 추상 메소드 (abstract method)
본체 없는 메소드
추상 메소드의 선언부에 abstract 키워드 사용
상속 시 반드시 구현해야 하는, 오버라이딩이 강제화되는 메소드
모든 자식 클래스에 다 들어가야하는데 자식마다 다 다르게 구현될 기능

[접근제한자] abstract 반환형 메소드명(자료형 변수명);


----------------------------------------------------------------------------------

인터페이스

하나의 클래스 안이 전부다 추상으로만 이루어져있는 것
메서드 -> 다 추상메서드 됨
변수 -> 다 static final 됨

객체를 만들기 위한 하나의 가이드

상수형 필드와 추상 메소드만을 작성할 수 있는 추상 클래스의 변형체
메소드 통일성을 부여하기 위해 추상 메소드만 따로 모아놓은 것으로
상속 시 인터페이스 내에 정의된 모든 추상메소드를 구현해야 함

[접근제한자] interface 인터페이스명 {

	// 상수도 멤버로 포함할 수 있음
	public static final 자료형 변수명 = 초기값;

	// 추상 메소드만 선언 가능
	[public abstract] 반환자료형 메소드명([자료형 매개변수]);
	// public abstract가 생략되기 때문에
	// 오버라이딩 시 반드시 public 표기해야 함
}


1. 상수 필드 
- 사용법 : [public static final] 자료형 필드명 = 값;
- [public static final] 생략 가능으로, 써도 되고 안써도 됨 (동일한 결과)
- 인퍼테이스는 초기화 블록, 생성자를 사용할 수 없기 때문에 반드시 선언과 동시에 초기값을 지정해야 함
double PI = 3.1415;

2. 추상 메소드
- [public abstract] 반환자료형 메소드명([자료형 매개변수]);
- [public abstract] 생략 가능으로 써도 되고 안 써도 됨 (동일한 결과)
void method01; -> 이 인터페이스 상속하는 애들은 무조건 method1이 있어야 한다.

3. 디폴트 메소드
- 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서 허용됨
- 인터페이스에 선언되지만 실제로는 객체가 가지고 있는 인스턴스 메소드가 됨
- 실제로는 해당 인터페이스를 포함한 클래스의 멤버 메소드가 됨
- 인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 
  이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.

- 사용법 : default 반환자료형 메소드명(매개변수);
default void method0101(){
	System.out.println("인터페이스01의 디폴트 메소드");
}

4. 정적 메소드
- 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능
- 사용법: [public] static 반환자료형 메소드명(매개변수);
- [public]을 생략해도 컴파일 시 자동으로 붙여 줌
static void method0102() {
	System.out.println("인터페이스01의 정적 메소드");
}

-> 객체 생성하지 않고 바로 실행파일에서
Interface01.method0102();
해서 사용할 수 있다.
- 인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.  


----------------------------------------------------------------------------------


기본 API (Application Programming Interface)
자바를 이용해서 개발하기 위해 어떻게 사용해야 할 지 정의 해 놓은 것


String 관련 클래스

String 클래스
- 문자열 값 수정 불가능, immutable(불변)
- 수정 시 수정된 문자열이 새로 할당 되어 새 주소를 넘김
- 값을 넣은 후에 새로운 값을 넣고 싶으면 아예 새로운 공간을 만들고 새로만든 공간의 주소를 준다.
- 수정 하지 않고 불러 들일 때는 좋다

예)
	String s1 = "Hello"; // 문자열은 객체처럼 다른 영역에 저장된다.
	System.out.println(System.identityHashCode(s1)); // 실제 그 공간의 주소를 알려달라
	s1 = "hihi";
	System.out.println(System.identityHashCode(s1));
//실행 결과
	2018699554
	1311053135
		
StringBuffer 클래스
- 문자열 값 수정 가능, mutable(가변)
- 수정, 삭제 등이 기존 문자열에 수정되어 적용
- 기본 16문자 크기로 지정된 버퍼를 이용하며 크기 증가 가능
- 쓰레드 safe기능 제공(성능 저하 요인)

StringBuilder 클래스
- StringBuffer와 동일하나 쓰레드 safe기능을 제공하지 않음
