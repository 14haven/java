2020년 11월 11일

날짜 관련 클래스

-Calendar 클래스
Calendar클래스는 생성자가 protected이기 때문에 new 연산자를 통해 객체 생성 불가능
getInstance() 메소드를 통해서 객체 생성

Calendar today = Calendar.getInstance(); // Calendar의 static 메소드를 실행 시킨 것
		
		System.out.println(today.get(Calendar.YEAR));
		System.out.println(today.get(Calendar.MONTH));

- GregorianCalendar 클래스
GregorianCalendar클래스는 Calendar클래스의 후손 클래스
년, 월, 일, 시, 분, 초 정보를 필드를 이용하여 다룰 수 있음

------------------------------------------------------------------------------------------

Format 관련 클래스

- SimpleDateFormat 클래스 (내가 원하는 형태로 출력하기 위해)
Date의 날짜, 시간 정보를 원하는 format으로 출력하는 기능 제공
java.text 패키지에 속해있음

Date dt = new Date();
System.out.println(dt.toString()); // 문자열 형태
System.out.println(dt); // 객체 형태 
SimpleDateFormat sdf = new SimpleDateFormat("yy-MM-dd HH:mm:ss");
System.out.println(sdf.format(dt)); -> 20-11-11 11:09:19

- Formatter 클래스 
값 출력 시 format 적용하여 출력
Formatter 객체 생성 시 변환된 결과를 보낼 곳의 정보를 생성자 인자로 전달

예)
Formatter f = new Formatter(System.out);
f.format("%d %f %s 로 출력할 서식 지정", 10, 3.5, "Hello");


------------------------------------------------------------------------------------------

제네릭(Generic)
데이터 타입이 어떤게 들어와도 됨
반환자료형이 어떤게 올지 모르지만 어떤게 들어와도 됨
-> 데이터 타입 어떤걸 넘겨주냐에 따라서 알아서 다르게 동작

- 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
- 클래스와 인터페이스, 메소드를 정의할 때 타입을 파라미터로 사용할 수 있도록 함
- 타입 파라미터는 코드 작성 시 구체적인 타입으로 대체되어 다양한 코드를 생성하도록 해줌
	=> 
	이 클래스 이용해서 내가 객체 만들게, 이 인터페이스 이용해서 참조변수 만들게
	정의하는 당시에는 데이터타입 지정x
	사용할 때 데이터타입 지정
	내가 지정하는 것에 따라서 알아서 동작	     


- 제네릭 프로그래밍
데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을
가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식

- 제네릭 장점
1. 컴파일 시 제네릭 코드에 대해 강한 타입 체크를 함
잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있음
2. 컬렉션, 람다식, 스트림, NIO에서 널리 사용됨
3. 불필요한 타입변환을 제거
제네릭 코드로 타입을 지정해 놓으면 해당 타입으로 사용할 때 타입변환을 하지 않아도 됨
( 일일이 여러개 만들 필요도 없고 캐스팅이나 타입변환을 하지 않아도 된다. )

- 제네릭 타입
타입을 피라미터로 가지는 클래스와 인터페이스
클래스 또는 인터페이스 이름 뒤에 <타입>기호를 추가
타입 피라미터는 변수와 동일한 규칙에 따라 작성
일반적으로 대문자 알파벳 한글자로 표현

- 제네릭 타입 정의
public class 클래스명<T>{...}
public interface 인터페이스명<T>{...}

------------------------------------------------------------------------------------------

- 제네릭 타입 사용
객체 생성 (이 클래스를 이런 타입으로 쓸게)
클래스명<사용할 타입> 참조변수명 = new 클래스명<사용할 타입>();
클래스명<사용할 타입> 참조변수명 = new 클래스명(); 

* 타입변수선언과 객체생성을 동시에 할 때 객체 생성부분의 타입 파라미터는 생략 가능

예)

public class GenericExam01<T> { //나 제네릭 쓸게, 제네릭 쓰는 부분은 T라고 적을게
	// 필드부
	public T var1;
	public T var2;
	
	// 생성자부
	public GenericExam01() {}
	public GenericExam01(T var1, T var2) {
		this.var1 = var1;
		this.var2 = var2;
	}
}

실행 클래스

//		/* 제네릭 전용 전 클래스 사용
//		 * - 매개변수 생성자: public GenericExam01(int var1, int var2)
//		 */
//		
//		GenericExam01 ge01 = new GenericExam01(10,20);	// 정상 사용 가능
//		//GenericExam01 ge02 = new GenericExam01(1.5,2.5);	// 오류 발생
//		GenericExam01 ge03 = new GenericExam01('A','B');	// 단일문자<=>정수 호환가능
//				// 정상사용 가능하나 정수형태 값으로 사용됨
//		//GenericExam01 ge04 = new GenericExam01("Hi","bye"); 	// 오류 발생
		


		/* 제네릭 전용 후 클래스 사용
		 * - 클래스 : public class GenericExam01<T>
		 * - 매개변수 생성자: public GenericExam01(T var1, T var2)
		 */
		
		//제네릭은 기본데이터타입을 제공하지 않는다. 내가 정수형태를 쓰고 싶다면? = Wrapper 사용
		GenericExam01<Integer> ge01 = new GenericExam01<Integer>(10,20);	// 정상 사용 가능
		GenericExam01<Double> ge02 = new GenericExam01<Double>(1.5,2.5);	// 정상 사용 가능
		GenericExam01<Character> ge03 = new GenericExam01<Character>('A','B');	// 정상 사용 가능
		GenericExam01<String> ge04 = new GenericExam01<String>("Hi","bye"); 	// 정상 사용 가능

------------------------------------------------------------------------------------------


- 제네릭 멀티 타입 미터
제네릭 타입은 두 개 이상의 멀티 타입 파라미터 사용 가능
각각 타입 파라미터를 콤마로 구분

제네릭 멀티 타입 정의
public class 클래스명<T,M>{...}
pulic interface 인터페이스명<T,M>{...}

제네릭 멀티 타입 사용
클래스명<사용할타입1,사용할타입2> 참조변수명 = new 클래스명();

public class GenericExam01<T,M> { //나 제네릭 쓸게, 제네릭 쓰는 부분은 T랑 M이라고 적을게
	// 필드부
	public T var1;
	public M var2;
	
	// 생성자부
	public GenericExam01() {}
	public GenericExam01(T var1, M var2) {
		this.var1 = var1;
		this.var2 = var2;
	}
}

실행클래스
	/* 제네릭 멀피파라메터 전용 후 클래스 사용
	 * - 클래스 : public class GenericExam01<T,M>
	 * - 매개변수 생성자: public GenericExam01(T var1, M var2)
	 */
	GenericExam01<Integer,Integer> ge01 = new GenericExam01<Integer,Integer>(10,20);	// 정상 사용 가능
	GenericExam01<Double,Double> ge02 = new GenericExam01<Double,Double>(1.5,2.5);	// 정상 사용 가능
	GenericExam01<Character,Character> ge03 = new GenericExam01<Character,Character>('A','B');	// 정상 사용 가능
	GenericExam01<String,String> ge04 = new GenericExam01<String,String>("Hi","bye"); 	// 정상 사용 가능
	GenericExam01<Integer,Double> ge05 = new GenericExam01<Integer,Double>(10,1.5);
	한줄에 적을 경우 뒤에 있는 T,M은 생략 가능
	예) GenericExam01<Integer,Double> ge05 = new GenericExam01(10,1.5);
	
	GenericExam01<Integer,Double> ge07 = new GenericExam01();
	ge07.var1 = 10; // 정수형으로 사용돼서 값 정상 대입
	//ge07.var1 = 1.5; // 정수형 공간에 실수값을 대입하려고 해서 에러 발생
	ge07.var2 = 0.5;
		
------------------------------------------------------------------------------------------


- 제네릭 메소드
매개타입과 리턴 타입으로 타입 파라미터를 갖는 메소드
리턴 타입 앞에 <타입> 기호를 추가 

제네릭 메소드 정의
public <T> 리턴타입 메소드명(매개변수,...){...}

제네릭 메소드 사용
<사용할 타입>메소드명(인자값);
메소드명(인자값);
*사용할 타입을 생략하면 인자값의 타입을 보고 타입을 추정함

예)
public <A> A method01(A num) { //이 메소드를 사용할 때 A라는 타입을 사용할거임 리턴타입도 A고 매개변수도 A
	return num;

실행파일
System.out.println(ge07.<Integer>method01(10)); // 정석
System.out.println(ge07.method01(10)); // 인자값을 보고 데이터 타입을 알 수 있기 때문에 생략 가능

------------------------------------------------------------------------------------------

제네릭
https://siyoon210.tistory.com/14
제네릭 클래스
https://siyoon210.tistory.com/15?category=839846
제네릭 와일드카드
https://siyoon210.tistory.com/16


- 제네릭 제한된 타입 파라미터

타입 파라미터로 지정되는 타입을 제한하기 위한 용도로 사용
( 우리가 자료형을 실제 사용하는 놈아, 니가 자료 저장해라 하니까 진짜 아무거나 저장함
내가 원하는 타입말고 다른 타입까지 막 입력할 가능성이 있음
-> 기능을 구현하는 데 문제가 생길 수 있음
이런 것들을 막기 위해 생긴 제한 타입 파라미터)

타입 파라미터 뒤에 extends 키워드를 붙이고 상위타입을 명시
	상위타입은 클래스와 인터페이스도 가능(모두 extends 키워드 사용)
타입 파라미터 변수로 상위타입의 멤버(필드,메소드)만 사용 가능

- 제네릭 제한된 타입 정의
public <T extends 상위타입> 리턴타입 메소드(매개변수){...}


예)

public class AnimalController<T extends Animal>{
 	public T ani; 	// Tiger와  Cat 객체를 담기 위한 부모클래스 참조변수(다형성 구현)
}
T에는 Animal과 Ainmal을 상속받은 애들만 들어갈 수 있다.


------------------------------------------------------------------------------------------

- 제네릭 와일드 카드 타입 파라미터
와일드카드란, 제네릭 클래스의 객체를 메소드의 매개변수로 받거나 반환자료형으로 쓸 때,
그 객체의 타입 변수를 제한하는 것을 말한다. 
(구체적인 타입대신 와일드 카드를 사용함으로써 사용자가 메소드를 사용할 때 직접 지정할 수 있도록)

코드에서 ?를 일반적으로 와일드 카드라고 부름

- 제네릭 와일드 카드 타입 사용 범위
제네릭 타입 <?> : 제한 없음
	(모든 클래스나 인터페이스 타입 사용 가능)
제네릭 타입 <? extends 상위타입> : 상위클래스 제한
	(명시된 상위타입이나 하위타입만 사용 가능)
제네릭 타입 <? super 하위타입> : 하위클래스 제한
	(명시된 하위타입이나 상위타입만 사용 가능)


예)
Animal 클래스
public class Animal <T>{ // 제네릭 클래스
	private T hp;
	public Animal() {}
	public Animal(T hp) {
		this.hp = hp;
	}
}

AnimalController 클래스
public class AnimalController{
public Animal ani; 	// Tiger와  Cat 객체를 담기 위한 부모클래스 참조변수(다형성 구현)
	// 생성자
	public AnimalController(Animal<?> ani) { 
// Animal 객체를 메소드의 매개변수로 사용
// Animal은 제네릭 클래스이기 때문에 데이터 값을 지정해줘야하는데 사용자가 지정하게 하기 위해 <?> 사용
		this.ani = ani;
	}
}

실행 클래스
AnimalController ac1 = new AnimalController(new Animal<Integer>(10));
AnimalController ac2 = new AnimalController(new Animal<Number>(1.5));
이런식으로 사용자가 직접 인자값을 넣을때 데이터형을 지정해줄 수 있다.

------------------------------------------------------------------------------------------


- 제네릭 타입의 상속과 구현
제네릭 타입의 클래스나 인터페이스를 상속 받을 경우 자식 클래스도 제네릭 타입으로 정의
(부모가 제네릭 타입이면 자식도 제네릭타입인게 좋다)
자식 제네릭 타입은 부모타입 외 추가로 타입 지정 가능

예)
public class ChildProduct<T,M> extends Product<T,M>{...}
public class ChildProduct<T,M,C> extends Product<T,M>{...}



------------------------------------------------------------------------------------------

- 컬렉션 (Collection)

메모리상에서 자료를 구조적으로 처리하는 방법을 자료구조라고 일컫는데
컬렉션(Collection)은 자바에서 제공하는 자료구조를 담담하는 프레임워크
(자료구조 = 데이터를 사용하기 위한 방법, 어떻게 저장하고 어떻게 접근해서 사용 할 것이조,
어떻게 수정하고 삭제하고 변경할 것인지 정리 해 놓은 것)

추가, 삭제, 정렬 등의 기능처리가 간단하게 해결 되어 자료구조적 알고리즘을 구현할 필요 없음

java.util 패키지에 포함되며, 인터페이스를 통해 정형화된 방법으로 다양한 컬렉션 클래스 이용 가능

------------------------------------------------------------------------------------------


- 자료구조
데이터(자료)를 메모리에서 구조적으로 처리하는 방법론
크게 네가지로 나뉜다.
1. 단순구조(변수) -> 일반 변수 사용하는 것
2. 선형구조 -> 변수 혹은 객체들을 일자형태로(이론적으로) 여러개 묶어서 사용하는 것, 묶는 방법은 다양하다, 대표적인 것: 배열
3. 비선형구조 -> 내 다음데이터가 하나가 될 수도 있고 두개가 될 수도 있고, 이 데이터들이 서로 연결돼 있을 수도 있는 비선형형태
4. 파일구조 -> 파일을 다루기 위한 구조


1. 단순구조(변수)
- 정수, 실수, 문자, 문자열

데이터가 많아지면 많아질수록 관리하기가 힘들다.
간단한 데이터들, 임시데이터를 처리할 때 좋다.

2. 선형구조
- 리스트(ex.배열)
- 연결리스트 
공간 자체는 붙어있지 않고 따로 저장 돼 있는데 
처음에 만들어진놈이 바로 다음에 만들어진 놈을 가리키고 있음(어디에 있는지 알고 있다는 뜻)
	단순 연결리스트
	이중 연결리스트(내가 내 다음애랑 내 전에 애를 앎)
	원형 리스트(다음애를 알고 있고 맨끝애는 맨 처음애를 알고 있음)
- 스택 
first in, last out 처음 들어간게 가장 마지막에 나온다
- 큐
- 덱

3. 비선형구조
- 트리
하나가 있으면, 그 아래 여러개 (ex.폴더구조)
	일반트리
	이진트리
-그래프
방향성은 없음, 나랑 연결 돼 있는 애가 다른 애랑도 연결 돼 있고 서로 서로 연결 돼 있는
	방향그래프
	무방향그래프

4. 파일구조
- 순차파일
- 색인파일
- 직접파일


------------------------------------------------------------------------------------------

- 배열의 문제점 & 컬렉션의 장점

배열의 문제점
1. 한 번 크기를 지정하면 변경할 수 없다.
필요에 따라 공간을 늘리거나 줄일 수 없음
공간 크기가 부족하면 에러가 발생
-> 할당 시 넉넉한 크기로 할당하게 됨 (메모리 낭비)

2. 기록된 데이터에 대한 중간 위치의 추가, 삭제가 불편하다.
추가, 삭제할 데이터부터 마지막 기록된 데이터까지 하나씩 뒤로 밀어내고 추가해야 함 (복잡한 알고리즘)

3. 한 타입의 데이터만 저장 가능하다.


컬렉션의 장점
1. 저장하는 크기의 제약이 없다.
2. 추가, 삭제, 정렬 등의 기능 처리가 간단하게 해결된다.
자료를 구조적으로 처리 하는 자료구조가 내장되어 있어 알고리즘 구현이 필요 없음
3. 여러 타입의 데이터가 저장 가능하다.
객체만 저장할 수 있기 때문에 필요에 따라 기본 자료형을 저장해야 하는 경우 Wrapper클래스 사용
	


------------------------------------------------------------------------------------------

컬렉션의 주요 인터페이스

collection 
- List 계열
- Set 계열

Map 은 컬렉션 상속(정확히는 인터페이스 구현) 받지 않는다.
별도로 만들어져있다.

- List 계열
순서를 유지하고 저장, 중복 저장 가능, 인덱스를 이용해서 접근

구현 클래스
ArrayList, Vector, LinkedList

- Set 계열
순서를 유지하지 않고 저장, 중복 저장 안됨
ex. 10,20,30 넣었는데 20,30,10으로 나올 수 있다.

구현 클래스
HashSet, TreeSet
( List에 있는 거 중복 제거 할 때 사용할 수 있다. )


-Map 계열
키와 값의 쌍으로 저장 
키: 값을 찾아가기 위한 이름
키는 중복 저장이 안됨
순서는 상관 없음

구현 클래스
HashMap, Hashtable, TreeMap, Properties
